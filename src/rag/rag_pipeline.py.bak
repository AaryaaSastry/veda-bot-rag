import config
from rag.retriever import Retriever
from rag.generator import Generator
from sentence_transformers import CrossEncoder
from rag.query_rewriter import rewrite_query


class RAGPipeline:

    def __init__(self, vector_db_path, api_key):
        self.retriever = Retriever(vector_db_path)
        self.generator = Generator(api_key)
        self.reranker = CrossEncoder(config.RERANKER_MODEL)

    def run(self, question, memory, source_filter=None):

        conversation_history = memory.get_formatted_history()
        user_turns = memory.user_turn_count

        rewritten_query = rewrite_query(
            generator=self.generator,
            conversation_history=conversation_history,
            current_question=question
        )

        print(f"Retrieving initial {config.K_RETRIEVAL} chunks...")
        retrieved_chunks = self.retriever.retrieve(rewritten_query, k=config.K_RETRIEVAL, source_filter=source_filter)

        if not retrieved_chunks:
            return ["No relevant information found."]

        print(f"Reranking to top {config.K_RERANK} chunks...")
        # Prepare pairs for cross-encoder
        pairs = [[rewritten_query, chunk['text']] for chunk in retrieved_chunks]
        scores = self.reranker.predict(pairs)
        
        # Add scores and sort
        for i, chunk in enumerate(retrieved_chunks):
            chunk['rerank_score'] = scores[i]
            
        reranked_chunks = sorted(
            retrieved_chunks, 
            key=lambda x: x['rerank_score'], 
            reverse=True
        )[:config.K_RERANK]

        print("Generating grounded answer...")
        answer = self.generator.generate(
            question=question,
            retrieved_chunks=reranked_chunks,
            conversation_history=conversation_history
        )

        return answer
